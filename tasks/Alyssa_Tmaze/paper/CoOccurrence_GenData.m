%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                     %%%
%%%                   Perform Co-Occurrence Analysis                    %%%
%%%                                                                     %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For Tmaze data
% This script loads the inputData generated by the script inputData_GenData
% as well as the candidate events generated by the script
% MASTER_Generate_Tmaze_Candidates or another similar script. 
% It computes the pairwise coactivity of left and right place cells.
%
% There are two output variables that can be saved:
%      cooc_data (used to generate cooc_results)
%      cooc_results (this goes into the plotting script)
%
%  Why are there two outputs? Because of bad planning.
%
% aacarey Oct 2015 (gl reading this code)
% MvdM Nov 2015 additions

clear 

%% WHAT DO YOU WANT THIS SCRIPT TO DO??

% what to load and where to find it
cfg.inputData_fn = 'inputData'; % the script knows the proper file extension (.mat) so don't put it here
cfg.inputData_fd = 'D:\My_Documents\Dropbox\projects\Alyssa'; % 'E:\Documents\TmazePaper\data';

% what to call the output and where to put it?
cfg.writeFiles = 1;
cfg.output_fn = 'CoOccurrence';
cfg.output_fd = cfg.inputData_fd;

% do you want use the candidates or the precandidates?
cfg.inputCand_fn = '-candidates'; % '-precandidates' or '-candidates'...make sure to include the hyphen to distinguish the similar names
% cfg.inputCand_fd = ''; % this will not be specified, just assumes
% that the candidates are in the session folders

% do you want to compute co-occurrence for the whole session, or only part
% of it? 
cfg.whichEvents = 'all'; % 'prerecord', 'all', 'postrecord', 'allITI', 'equalBehaviorITI'

% which events to use for computing shuffled (expected) co-occurrence?
cfg.shuffleQ = 'selectedEvents'; % 'selectedEvents' or 'allEvents' 

% which spiketrains to use? * note that these are saved inside of inputData
cfg.whichS = 'unique'; % 'unique' or 'nonunique'; unique cells are left-only 
% or right-only, and nonunique are any cells with left fields and any cells 
% with right fields, even if they have fields on the opposite arm. nonunique 
% includes unique 

% WHICH RATS (caution, highly suggested to include all rats)
cfg.rats = {'R042','R044','R050','R064'}; 
% 'R042','R044','R050','R064' note that it's probably safer do 
% all rats at the same time so that we can guarantee that all co-occurrence 
% data is generated using the same parameters

% some parameters you can change
cfg.nShuffle = 250;

% TODO which co-coccurrence method to use? ChengFrank, Dupret?

% TODO what time bin to use for co-occurrence? Default is start and end of
% event, but need to be able to override with fixed width

% TODO exclude pairs from same tetrode if requested

%% Make sure the user didn't make a typo or whatever, but at the same time, print some useful info to the command window

iWasHere = pwd; % save where I started before cding all over the place
fprintf('\nYou have selected the following rats:\n')
for iRat = 1:length(cfg.rats)
    switch cfg.rats{iRat}
        case 'R042'
            disp('R042: Captain Ratsworth at your command ;)')
        case 'R044'
            disp('R044')
        case 'R050'
            disp('R050')
        case 'R064'
            disp('R064')
        otherwise
            error('Unrecognized rat in cfg.rats')
    end
end

disp(' ')
switch cfg.whichS
    case 'unique'
        disp('You have selected [unique] left-only and right-only spiketrains')
        cfg.whichS = 'Sunique_full'; % _full is important, ensures using non-speed-restricted S
    case 'nonunique'
        disp('You have selected [nonunique] left and right spiketrains')
        cfg.whichS = 'S_full';
    otherwise
        error('Unrecognized cfg.whichS. Better check that spelling ^_^')
end

disp(' ')
switch cfg.whichEvents 
    case 'all'
        disp('You have selected to perform co-occurrence analysis on all candidates')
    case 'prerecord'
        disp('You have selected to perform co-occurrence analysis on prerecord candidates')
    case 'postrecord'
        disp('You have selected to perform co-occurrence analysis on postrecord candidates')
    case 'allITI'
        disp('You have selected to perform co-occurrence analysis on all intertrial intervals')
    case 'equalBehaviorITI'
        disp('You have selected to perform co-occurrence analysis on intertrial intervals with equal preceding behavior')
    otherwise
        error('Unrecognized cfg.whichEvents. Better check that spelling ^_^')
end

% set some non-configurable variables
arms = {'L','R'}; % shortforms for left and right arms, used for storing corresponding data

%% Load the inputData

cd(cfg.inputData_fd)
load([cfg.inputData_fn,'.mat'])

disp(' ')
disp(['This inputData was generated on ',inputData.date])

% I'm just going to get the first part of the data path, so it doesn't
% matter how many rats I load
fd = getTmazeDataPath([]);
[base_fp,~,~] = fileparts(fd{1}); % on first pass: E:\data\promoted\R042
[base_fp,~,~] = fileparts(base_fp); % on second pass: E:\data\promoted... bit hacky?
% should maybe make function getBaseFP or something

%% let's do a loop thing through the rats

for iRat = 1:length(cfg.rats)
    fprintf('\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n')
    fprintf('~~  GENERATING CO-OCCURRENCE DATA FOR %s ~~\n',cfg.rats{iRat});
    disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
    
    for iSession = 1:length(inputData.(cfg.rats{iRat}))
        sessionID = inputData.(cfg.rats{iRat})(iSession).sessionID; fprintf('\nWorking on %s\n',sessionID);
        
        % save some data into the output struct
        sessionCooc.sessionID = sessionID;
        sessionCooc.restrictionType = inputData.(cfg.rats{iRat})(iSession).restrictionType;
        
        % load and rename the variable
        cd([base_fp,'\',cfg.rats{iRat},'\',sessionID]) 
        evt = load([sessionID,cfg.inputCand_fn]); % assign the loaded variable to "evt" regardless of what it is actually called
        % if the variable is called "precandidates", evt will be
        % evt.precandidates.tstart and so on, and this is annoying and
        % stupid so do another stupid thing to fix it:
        
        % hack to unpack the struct...or whatever
        name = fieldnames(evt); evt = evt.(name{1});
        
        LoadExpKeys; LoadMetadata;
        
        % choose which events to use       
        fprintf('nEvents loaded: %d\n',length(evt.tstart));
        evt_original = evt; % keep full set for later if needed
        switch cfg.whichEvents % now restrict
            case 'all'
                % do nothing with evt restriction
            case 'prerecord'
                evt = restrict(evt,ExpKeys.prerecord(1),ExpKeys.prerecord(2));
            case 'postrecord'
                evt = restrict(evt,ExpKeys.postrecord(1),ExpKeys.postrecord(2));
            case 'allITI'
                evt = restrict(evt,metadata.taskvars.rest_iv.tstart(1),metadata.taskvars.rest_iv.tend(end));
            case 'equalBehaviorITI'
                eq_iv = GetEqualBehaviorIV([],metadata);
                evt = restrict(evt,eq_iv);
            otherwise
                error('Unrecognized cfg.whichEvents')
        end
        fprintf('nEvents after cfg.whichEvents restrict: %d\n',length(evt.tstart));
        
        % make a Q-matrix
        %A Q-matrix is organized such that each row corresponds to a cell, and each
        %column groups the spikes into time bins. Thus, each column contains information
        %about which cells were active together in a given time bin.
        
        for iArm = 1:length(arms)
            sessionCooc.(arms{iArm}).Q = [];
            if ~isempty(inputData.(cfg.rats{iRat})(iSession).(arms{iArm}).(cfg.whichS).t) 
                for iEvt = length(evt.tstart):-1:1
                    cfg_temp = [];
                    cfg_temp.tvec_edges = [evt.tstart(iEvt) evt.tend(iEvt)];
                    
                    % TODO: select requested time bin here: default is just start
                    % and end of event
                    cfg_temp.dt = diff(cfg_temp.tvec_edges);
                    
                    qtemp = MakeQfromS(cfg_temp,inputData.(cfg.rats{iRat})(iSession).(arms{iArm}).(cfg.whichS));
                    sessionCooc.(arms{iArm}).Q(:,iEvt) = qtemp.data;
                    
                end % of events
                
                % also compute full Q-matrix if needed -- TODO: avoid
                % duplication
                switch cfg.shuffleQ
                    case 'selectedEvents'
                        % do nothing
                    case 'allEvents' % compute full Q-matrix
                        for iEvt = length(evt_original.tstart):-1:1
                            cfg_temp = [];
                            cfg_temp.tvec_edges = [evt_original.tstart(iEvt) evt_original.tend(iEvt)];
                            
                            % TODO: select requested time bin here: default is just start
                            % and end of event
                            cfg_temp.dt = diff(cfg_temp.tvec_edges);
                            
                            qtemp = MakeQfromS(cfg_temp,inputData.(cfg.rats{iRat})(iSession).(arms{iArm}).(cfg.whichS));
                            sessionCooc.(arms{iArm}).fullQ(:,iEvt) = qtemp.data;
                            
                        end % of events
                    otherwise
                       error('Unknown shuffleQ option specified.');
                end % of shuffleQ switch
            end % of passing cell number check
        end % of arms
        
        % compute co-occurrence (this could have been done in the loop
        % above, but w/e
        
        for iArm = 1:length(arms)
            cfg_temp = [];
            cfg_temp.nShuffle = cfg.nShuffle; 
            cfg_temp.outputFormat = 'vectorU'; % MvdM: does this do anything?
            
            switch cfg.shuffleQ
                case 'selectedEvents'
                    cfg_temp.fullQ = [];
                case 'allEvents'
                    cfg_temp.fullQ = sessionCooc.(arms{iArm}).fullQ;
            end
            
            % TODO: add possibility of tt_mask if requested
            
            Q_temp = []; Q_temp.data = sessionCooc.(arms{iArm}).Q; % CoOccurQ expects the Q-matrix to be in a Q.data field
            sessionCooc.(arms{iArm}).ALLp = CoOccurQ(cfg_temp,Q_temp); 
        end
        
        % also do the co-occurrence for L and R cells in the same event
        % (not done yet)
        
        
        
        
        
        % put it in the output variable
        cooc_data.(cfg.rats{iRat})(iSession) = sessionCooc;
        
    end
end

%%
if cfg.writeFiles
    disp(['Writing inputData to .mat file in ',cfg.output_fd,'...'])
    cd(cfg.output_fd)
    save(cfg.output_fn,'cooc_data')
else
    disp('WARNING: You have selected not to save the inputData')
end

disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
disp('~~~            End of inputData run                ~~~')
disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
toc
cd(iWasHere)
